#        [0,                 n = 0
# F_n =  {1,                 n = 1
#        [F_n-1 + F_n-2      n > 1

# РЕАЛИЗАЦИЯ 1 - Рекрусия
def fib_1(n):
    assert n >= 0
    return n if n <= 1 else fib_1(n - 1) + fib_1(n - 2)


'''
Разберёмся с причинами медленной работы алгоритма. Для этого необходимо посмтроить рекурсвиную схему, которая
позволит показать дерево рекурсий, где можно заметить, что некоторые числа фибоначи рассчитываются многократно.
Данную проблему можно устранить, не производят повторные рассчёты.
'''

# РЕАЛИЗАЦИЯ 2
'''
Выполним оптимизацию, исключив повторные рассчёты чисел фибоначи. Для этого заведём глобальную переменную, в которой
будем хранить уже числа фибоначи, которые мы вычислили ранее.
'''

cash = {}


def fib_2(n):
    assert n >= 0
    if n not in cash:
        cash[n] = n if n <= 1 else fib_2(n - 1) + fib_2(n - 2)

    return cash[n]


# РЕАЛИЗАЦИЯ 3
'''
Недостаток данного метода заключается в том, что мы имеем глобальную переменную cash, которую можно модифицировать,
из-за этого мы получим ложные результаты.
Для этого напишем декоратор memo, который создаёт локальную переменную cash, затем запоминает результаты вызова
декарируемой функции в cash.

Основным плюсом и использованием декоратора memo, является то, что мы можем использовать его с функциями, которые
не содержат в себе кэширование, например, прерварить РЕАЛИЗАЦИЮ 1 в РЕАЛИЗАЦИЮ 2, что мы сейчас и выполним ниже.
'''


# Создаём декоратор
def memo(f):
    cash_local = {}

    # Функция обвёртка
    def inner(n):
        if n not in cash_local:
            cash_local[n] = f(n)
        return cash_local[n]

    return inner


# Способ 1
# fib_1 = memo(fib_1)
# print(fib_1(80))

# Способ 2
# Указать @memo перед созданием функции fib_1

# Способ 3
# from functools import lru_cache
# fib_1 = lru_cache(maxsize= None)(fib_1)

# РЕАЛИЗАЦИЯ 4
'''
Главным недостатком данного метода является ошибка RecursionError: maximum recursion depth exceeded in comparison,
поэтому нет возможности найти большие числа фибоначи.

Будем использовать итерации вместо рекурсии.
'''


def fib_3(n):
    assert n >= 0
    f0, f1 = 0, 1
    for i in range(n - 1):
        f0, f1 = f1, f0 + f1
    return f1


# ФУНКЦИЯ ИЗМЕРЕНИЯ СКОРОСТИ РАБОТЫ

import time


def timed(f, *args, n_iter=100):
    acc = float('inf')
    for i in range(n_iter):
        t0 = time.perf_counter()
        f(*args)
        t1 = time.perf_counter()
        acc = min(acc, t1 - t0)
    return acc