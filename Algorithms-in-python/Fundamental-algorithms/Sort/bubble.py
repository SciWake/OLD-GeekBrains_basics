'''
Сортировка - это упорядочивание элементов любой структуры хранения данных в соответсвии с выбранным критерием.
Обзор алгоритма сорировки пузырьком:
    * Сложность: O(n^2);
    * Устойчивость (стабильность): Устойчивая. Если в массиве встречается два одинаковых элемента, то их порядок
    не меняется;
    * Тип (категория): Обменная;
    * Потребление памяти: Не требует дополнительной памяти.

Принцип работы: Берём первый элемент и сравниваем его со вторым элементом, если первый элемент оказался больше второго,
то мы меняем их местами. Далее мы сравнимваем второй элемент с третьим и если требуется, то снова производим обмен
элементов. Так мы пройдёмся по всему списку и самый большой элемент окажется справа (как самый большой пузырёк,
всплывёт вверх). После, возвращаемся к началу массива и повторяем все действия  снова и так до тех пор, пока не
весь массив не будет упорядочен.
'''

# РЕАЛИЗАЦИЯ 1
'''
Можно сделать одно важное наблюдение: после полного прохода по массиву хотя бы одно число (а именно – самое большое) 
будет поставлено на свое место.

Теперь, если мы сделаем второй проход по массиву, то еще одно число встанет на свое место. Значит, чтобы гарантированно 
получить отсортированный массив, надо сделать столько проходов, сколько элементов в массиве. 

Впрочем, достаточно сделать n - 1 проход, потому что когда все числа кроме одного будут на своих местах, последнее тоже 
само собой окажется на своем месте. 
'''
mass = [x for x in reversed([i for i in range(1, 20)])]


def bubble_1(array):
    for j in range(len(array) - 1):
        for i in range(len(array) - 1):
            if array[i] > array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]


# python -m timeit -n 1000 "import bubble" "bubble.bubble_1(bubble.mass)"
# 1000 loops, best of 5: 35.1 usec per loop


# РЕАЛИЗАЦИЯ 2

'''
Представим себе, что у нас есть массив на два миллиона чисел, и мы уже сделали миллион проходов. Это значит, что как 
минимум миллион чисел в массиве уже стоят на своих законных местах в конце массива. Следовательно, нет никакого смысла 
проходить правую половину массива, потому что там никаких изменений точно уже не будет. 

Итак, если на первом проходе мы делаем n - 1 сравнение, то на втором достаточно n - 2, на третьем  достаточно n - 3 и 
так далее по мере увеличения количества чисел, которые стоят на своих местах. Таким образом кусочек программы, 
отвечающий за сортировку можно переписать так:
'''


def bubble_2(array):
    for j in range(len(array) - 1):
        for i in range(len(array) - 1 - j):
            if array[i] > array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]


# python -m timeit -n 1000 "import bubble" "bubble.bubble_2(bubble.mass)"
# 1000 loops, best of 5: 21.3 usec per loop


# РЕАЛИЗАЦИЯ 3

'''
Второе соображение для оптимизации метода простого обмена основано на таком утверждении: если за полный проход в 
массиве не сделано ни одной перестановки, то его можно считать отсортированным. Это позволяет значительно сократить 
время в случаях, когда более или менее повезло с исходными данными.

Существенных изменений в структуре программы не будет – как был двойной цикл, так и остался. Просто внешний цикл будет 
заменен на цикл с условием. Программа в этом случае может выглядеть, например, так:
'''


def bubble_result(array):
    j = len(array) - 1
    swapped = True
    while swapped:
        swapped = False
        for i in range(0, j):
            if array[i] > array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                swapped = True
        j -= 1

# python -m timeit -n 1000 "import bubble" "bubble.bubble_result(bubble.mass)"
# 1000 loops, best of 5: 2.15 usec per loop
