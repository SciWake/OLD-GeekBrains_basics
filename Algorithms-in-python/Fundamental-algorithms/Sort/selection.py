'''
Обзор алгоритма сорировки выбором:
    * Сложность: O(n^2);
    * Устойчивость (стабильность): Устойчивая / неустойчивая - зависит от реализации;
    * Тип (категория): Выбором;
    * Потребление памяти: Не требует дополнительной памяти.

Принцип работы: Массив делится на две части - отсротированная и неотсротированная часть. Изначально, весь массив - это
одна неостротированная часть. На первом этапе мы находим наименьший элемент неотсортированной части массива, после мы
меняем его местами с первым элементом с неотсортированной частью массива (Так как массив не отсортированный помещаем
на первое место массива). После этого, нулевая ячейка массива считается остротированной.
Далее, повторяем эти действия до полной сортировки. На каждом этапе внешнего цикла, левая часть отсортированного массива
будет увиличиваться на 1 элемент, а права уменьшаться.
'''
mass = [x for x in reversed([i for i in range(1, 20)])]


def selection_sort(array):
    for i in range(len(array) - 1):
        min_index = i

        for j in range(i + 1, len(array)):
            if array[j] < array[min_index]:
                min_index = j

        array[i], array[min_index] = array[min_index], array[i]

# python -m timeit -n 1000 "import selection" "selection.selection_sort(selection.mass)"
# 1000 loops, best of 5: 20.2 usec per loop
