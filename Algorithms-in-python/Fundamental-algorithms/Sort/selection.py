'''
Обзор алгоритма сорировки выбором:
    * Сложность: O(n^2);
    * Устойчивость (стабильность): Устойчивая / неустойчивая - зависит от реализации;
    * Тип (категория): Выбором;
    * Потребление памяти: Не требует дополнительной памяти.

Принцип работы: Массив делится на две части - отсротированная и неотсротированная часть. Изначально, весь массив - это
одна неостротированная часть. На первом этапе мы находим наименьший элемент неотсортированной части массива, после мы
меняем его местами с первым элементом с неотсортированной частью массива (Так как массив не отсортированный помещаем
на первое место массива). После этого, нулевая ячейка массива считается остротированной.
Далее, повторяем эти действия до полной сортировки. На каждом этапе внешнего цикла, левая часть отсортированного массива
будет увиличиваться на 1 элемент, а права уменьшаться.
'''
mass = [x for x in reversed([i for i in range(1, 20)])]


# РЕАЛИЗАЦИЯ 1

def selection_sort(array):
    for i in range(len(array) - 1):
        min_index = i

        for j in range(i + 1, len(array)):
            if array[j] < array[min_index]:
                min_index = j

        array[i], array[min_index] = array[min_index], array[i]


# python -m timeit -n 1000 "import selection" "selection.selection_sort(selection.mass)"
# 1000 loops, best of 5: 28 usec per loop


# РЕАЛИЗАЦИЯ 2
'''
Второе соображение для оптимизации метода простого обмена основано на таком утверждении: если за полный проход в 
массиве не сделано ни одной перестановки, то его можно считать отсортированным. Это позволяет значительно сократить 
время в случаях, когда более или менее повезло с исходными данными. Для такой реализации потребовалось находить не
наименьший элемент, а наибольший, что позволило упросить написание кода.
'''


def selection_sort_2(array):
    j = len(array) - 1
    swapped = True
    while swapped:
        swapped = False
        max_index = j
        for i in range(0, j):
            if array[i] > array[max_index]:
                max_index = i
                swapped = True

        array[j], array[max_index] = array[max_index], array[j]
        j -= 1

# python -m timeit -n 1000 "import selection" "selection.selection_sort_2(selection.mass)"
# 1000 loops, best of 5: 2.8 usec per loop
